#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
plot_dynamics.py
Visualization of state trajectories vs. regulatory constraints.
Reads audit_log.json generated by certified_dynamics.py and produces 2D plots.
"""

import json
import numpy as np
import matplotlib
matplotlib.use("Agg")  # Non-interactive backend for headless environments
import matplotlib.pyplot as plt
from datetime import datetime
from pathlib import Path
from typing import Callable, List, Dict, Optional

# Professional style configuration (adjustable for technical reports)
try:
    # Preferred style for matplotlib 3.6+ where seaborn styles were renamed
    plt.style.use('seaborn-v0_8-whitegrid')
except Exception:
    try:
        # Fallback for older matplotlib versions
        plt.style.use('seaborn-whitegrid')
    except Exception:
        # If neither seaborn style is available, continue with default style
        pass
plt.rcParams.update({
    'font.size': 10,
    'axes.titlesize': 12,
    'axes.labelsize': 10,
    'figure.figsize': (10, 6),
    'figure.dpi': 150,
    'savefig.bbox': 'tight',
    'savefig.dpi': 300
})

class DynamicsPlotter:
    """Generates visualizations from CertifiedAdmissibleSpace audit logs."""
    
    STATUS_COLORS = {
        'FULLY_ADMISSIBLE': '#2ecc71',      # Green
        'MIXED_BOUNDARY': '#f39c12',        # Orange
        'INADMISSIBLE': '#e74c3c',          # Red
        'CONDITIONAL_PENDING': '#3498db'    # Blue
    }
    
    def __init__(self, log_path: str = "audit_log.json"):
        self.log_path = Path(log_path)
        self.data = self._load_log()
        
    def _load_log(self) -> List[Dict]:
        if not self.log_path.exists():
            raise FileNotFoundError(f"Audit log not found: {self.log_path}")
        with open(self.log_path, 'r') as f:
            return json.load(f)
    
    def plot_state_trajectory(self, 
                             state_idx: int = 0,
                             state_label: str = "State Variable",
                             constraint_name: Optional[str] = None,
                             threshold_fn: Optional[Callable[[float], float]] = None,
                             title: Optional[str] = None,
                             output_path: Optional[str] = None):
        """
        Plot the evolution of a state variable vs. its regulatory limit.
        
        Args:
            state_idx: Index of the variable in state_vector to plot.
            state_label: Label for the Y axis.
            constraint_name: Name of the constraint to label the boundary.
            threshold_fn: Function f(t) that calculates the limit at simulation time.
            title: Custom chart title.
            output_path: If provided, saves the chart to this path.
        """
        if not self.data:
            raise ValueError("No data to plot")
            
        # Extract time series
        sim_times = [entry['simulation_time'] for entry in self.data]
        state_values = []
        for i, entry in enumerate(self.data):
            if 'state_vector' not in entry:
                raise ValueError(
                    f"Entry at index {i} is missing 'state_vector'; cannot plot state index {state_idx}."
                )
            state_vector = entry['state_vector']
            try:
                length = len(state_vector)
            except TypeError:
                raise ValueError(
                    f"'state_vector' at entry index {i} is not indexable (type: {type(state_vector).__name__}); "
                    f"cannot plot state index {state_idx}."
                )
            if state_idx < 0 or state_idx >= length:
                sim_time = entry.get('simulation_time', 'unknown')
                raise ValueError(
                    f"Requested state_idx {state_idx} is out of bounds for entry {i} at simulation_time={sim_time}. "
                    f"'state_vector' length is {length}."
                )
            state_values.append(state_vector[state_idx])
        statuses = [entry['status'] for entry in self.data]
        
        # Calculate regulatory boundary if function is provided
        if threshold_fn:
            thresholds = [threshold_fn(t) for t in sim_times]
        else:
            thresholds = None
        
        # Create figure
        fig, ax = plt.subplots()
        
        # Plot state trajectory with colors by status
        labeled_statuses = set()
        for i in range(len(sim_times) - 1):
            color = self.STATUS_COLORS.get(statuses[i], '#95a5a6')
            label = statuses[i] if statuses[i] not in labeled_statuses else ""
            ax.plot([sim_times[i], sim_times[i+1]], 
                   [state_values[i], state_values[i+1]], 
                   color=color, linewidth=2.5, label=label)
            labeled_statuses.add(statuses[i])
        
        # Plot points with distinctive markers
        for t, val, status in zip(sim_times, state_values, statuses):
            ax.scatter(t, val, c=self.STATUS_COLORS.get(status, '#95a5a6'), 
                      s=50, edgecolors='white', linewidth=1.5, zorder=5)
        
        # Plot regulatory boundary if available
        if thresholds:
            ax.plot(sim_times, thresholds, 'k--', linewidth=1.5, 
                   label=constraint_name or "Regulatory Boundary")
            ax.fill_between(sim_times, thresholds, np.max(state_values)*1.1, 
                           alpha=0.1, color='red', label="Inadmissible Region")
        
        # Mark evidence events (status transitions from CONDITIONAL_PENDING -> FULLY_ADMISSIBLE)
        evidence_labeled = False
        for i in range(1, len(statuses)):
            if statuses[i-1] == 'CONDITIONAL_PENDING' and statuses[i] == 'FULLY_ADMISSIBLE':
                label = "Evidence Gate Fulfilled" if not evidence_labeled else ""
                ax.axvline(x=sim_times[i], color='green', linestyle=':', 
                          linewidth=1, alpha=0.7, label=label)
                evidence_labeled = True
        
        # Axis configuration and legend
        ax.set_xlabel("Simulation Time (arbitrary units)", fontsize=10)
        ax.set_ylabel(state_label, fontsize=10)
        ax.set_title(title or f"State Evolution: {state_label} vs Regulatory Boundary", fontsize=12, pad=15)
        
        # Legend handling duplicates
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys(), loc='best', framealpha=0.9)
        
        # Grid and layout
        ax.grid(True, alpha=0.3, linestyle='--')
        ax.set_axisbelow(True)
        
        # Add tooltip-style annotations for key points (limit to avoid clutter)
        MAX_ANNOTATIONS = 30
        annot_candidates = [
            entry for entry in self.data
            if entry.get('status') in ['INADMISSIBLE', 'CONDITIONAL_PENDING']
        ]
        if len(annot_candidates) > MAX_ANNOTATIONS:
            step = max(1, (len(annot_candidates) + MAX_ANNOTATIONS - 1) // MAX_ANNOTATIONS)
            annot_candidates = annot_candidates[::step]

        for entry in annot_candidates:
            reason = entry.get('reason', '')
            reason_text = reason[:30] + '...' if len(reason) > 30 else reason
            ax.annotate(f"\u26a0 {reason_text}", 
                       xy=(entry['simulation_time'], entry['state_vector'][state_idx]),
                       xytext=(0, 30), textcoords='offset points',
                       fontsize=8, bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.3),
                       arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.15'))
        
        plt.tight_layout()
        
        if output_path:
            try:
                plt.savefig(output_path)
                print(f"[Plot] Chart saved to: {output_path}")
            except IOError as e:
                print(f"[Plot] Failed to save chart to {output_path}: {e}")
        

    def generate_summary_report(self, output_path: str = "compliance_summary.json"):
        """Generate an executive summary in JSON with key metrics."""
        if not self.data:
            return {}
            
        status_counts = {}
        for entry in self.data:
            status = entry['status']
            status_counts[status] = status_counts.get(status, 0) + 1
            
        total_evaluations = len(self.data)

        summary = {
            "report_generated": datetime.now().isoformat(),
            "total_evaluations": total_evaluations,
            "time_span": {
                "start": self.data[0]['simulation_time'],
                "end": self.data[-1]['simulation_time']
            },
            "status_distribution": status_counts,
            "compliance_rate": (
                status_counts.get('FULLY_ADMISSIBLE', 0) / total_evaluations
                if total_evaluations
                else 0.0
            ),
            "critical_violations": [
                {
                    "time": entry['simulation_time'],
                    "reason": entry['reason'],
                    "violations": entry['violations']
                }
                for entry in self.data if entry['status'] == 'INADMISSIBLE'
            ],
            "evidence_gates_triggered": [
                {
                    "time": entry['simulation_time'],
                    "reason": entry['reason']
                }
                for entry in self.data if 'GATE' in entry['reason']
            ]
        }
        
        try:
            with open(output_path, 'w') as f:
                json.dump(summary, f, indent=2, default=str)
            print(f"[Report] Summary saved to: {output_path}")
        except IOError as e:
            print(f"[Report] Failed to save summary to {output_path}: {e}")
        return summary


# ==========================================
# USAGE EXAMPLE WITH THE LOG FROM THE MAIN MODULE
# ==========================================
if __name__ == "__main__":
    # Instantiate plotter with the log generated by certified_dynamics.py
    plotter = DynamicsPlotter("audit_log.json")
    
    # Example 1: Noise vs. dynamic regulatory limit chart
    # The limit was: 80 * (1 - 0.0125*t), i.e. reduced by 1 dB per year
    plotter.plot_state_trajectory(
        state_idx=0,
        state_label="Noise Level (dB)",
        constraint_name="CS-23 Noise Limit",
        threshold_fn=lambda t: 80 * (1 - 0.0125 * t),  # Limit function over time
        title="Urban Air Mobility: Noise Compliance Trajectory",
        output_path="noise_compliance_plot.png"
    )
    
    # Example 2: Generate executive summary in JSON
    summary = plotter.generate_summary_report("compliance_summary.json")
    print(f"\nCompliance rate: {summary['compliance_rate']*100:.1f}%")
    print(f"Critical violations: {len(summary['critical_violations'])}")
