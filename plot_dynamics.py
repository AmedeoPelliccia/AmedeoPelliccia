#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
plot_dynamics.py
Visualization of state trajectories vs. regulatory constraints.
Reads audit_log.json generated by certified_dynamics.py and produces 2D plots.
"""

import json
import numpy as np
import matplotlib
matplotlib.use("Agg")  # Non-interactive backend for headless environments
import matplotlib.pyplot as plt
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional

# Professional style configuration (adjustable for technical reports)
plt.style.use('seaborn-v0_8-whitegrid')
plt.rcParams.update({
    'font.size': 10,
    'axes.titlesize': 12,
    'axes.labelsize': 10,
    'figure.figsize': (10, 6),
    'figure.dpi': 150,
    'savefig.bbox': 'tight',
    'savefig.dpi': 300
})

class DynamicsPlotter:
    """Generates visualizations from CertifiedAdmissibleSpace audit logs."""
    
    STATUS_COLORS = {
        'FULLY_ADMISSIBLE': '#2ecc71',      # Green
        'MIXED_BOUNDARY': '#f39c12',        # Orange
        'INADMISSIBLE': '#e74c3c',          # Red
        'CONDITIONAL_PENDING': '#3498db'    # Blue
    }
    
    def __init__(self, log_path: str = "audit_log.json"):
        self.log_path = Path(log_path)
        self.data = self._load_log()
        
    def _load_log(self) -> List[Dict]:
        if not self.log_path.exists():
            raise FileNotFoundError(f"Audit log not found: {self.log_path}")
        with open(self.log_path, 'r') as f:
            return json.load(f)
    
    def plot_state_trajectory(self, 
                             state_idx: int = 0,
                             state_label: str = "State Variable",
                             constraint_name: Optional[str] = None,
                             threshold_fn: Optional[callable] = None,
                             title: Optional[str] = None,
                             output_path: Optional[str] = None):
        """
        Plot the evolution of a state variable vs. its regulatory limit.
        
        Args:
            state_idx: Index of the variable in state_vector to plot.
            state_label: Label for the Y axis.
            constraint_name: Name of the constraint to label the boundary.
            threshold_fn: Function f(t) that calculates the limit at simulation time.
            title: Custom chart title.
            output_path: If provided, saves the chart to this path.
        """
        if not self.data:
            raise ValueError("No data to plot")
            
        # Extract time series
        sim_times = [entry['simulation_time'] for entry in self.data]
        state_values = [entry['state_vector'][state_idx] for entry in self.data]
        statuses = [entry['status'] for entry in self.data]
        
        # Calculate regulatory boundary if function is provided
        if threshold_fn:
            thresholds = [threshold_fn(t) for t in sim_times]
        else:
            thresholds = None
        
        # Create figure
        fig, ax = plt.subplots()
        
        # Plot state trajectory with colours by status
        for i in range(len(sim_times) - 1):
            color = self.STATUS_COLORS.get(statuses[i], '#95a5a6')
            ax.plot([sim_times[i], sim_times[i+1]], 
                   [state_values[i], state_values[i+1]], 
                   color=color, linewidth=2.5, label=statuses[i] if i==0 else "")
        
        # Plot points with distinctive markers
        for t, val, status in zip(sim_times, state_values, statuses):
            ax.scatter(t, val, c=self.STATUS_COLORS.get(status, '#95a5a6'), 
                      s=50, edgecolors='white', linewidth=1.5, zorder=5)
        
        # Plot regulatory boundary if available
        if thresholds:
            ax.plot(sim_times, thresholds, 'k--', linewidth=1.5, 
                   label=constraint_name or "Regulatory Boundary")
            ax.fill_between(sim_times, thresholds, np.max(state_values)*1.1, 
                           alpha=0.1, color='red', label="Inadmissible Region")
        
        # Mark evidence events (status transitions from CONDITIONAL_PENDING -> FULLY_ADMISSIBLE)
        for i in range(1, len(statuses)):
            if statuses[i-1] == 'CONDITIONAL_PENDING' and statuses[i] == 'FULLY_ADMISSIBLE':
                ax.axvline(x=sim_times[i], color='green', linestyle=':', 
                          linewidth=1, alpha=0.7, label="Evidence Gate Fulfilled")
        
        # Axis configuration and legend
        ax.set_xlabel("Simulation Time (arbitrary units)", fontsize=10)
        ax.set_ylabel(state_label, fontsize=10)
        ax.set_title(title or f"State Evolution: {state_label} vs Regulatory Boundary", fontsize=12, pad=15)
        
        # Legend handling duplicates
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys(), loc='best', framealpha=0.9)
        
        # Grid and layout
        ax.grid(True, alpha=0.3, linestyle='--')
        ax.set_axisbelow(True)
        
        # Add tooltip-style annotations for key points
        for entry in self.data:
            if entry['status'] in ['INADMISSIBLE', 'CONDITIONAL_PENDING']:
                ax.annotate(f"\u26a0 {entry['reason'][:30]}...", 
                           xy=(entry['simulation_time'], entry['state_vector'][state_idx]),
                           xytext=(0, 30), textcoords='offset points',
                           fontsize=8, bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.3),
                           arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.15'))
        
        plt.tight_layout()
        
        if output_path:
            plt.savefig(output_path)
            print(f"[Plot] Chart saved to: {output_path}")
        
        plt.close(fig)
        return fig, ax

    def generate_summary_report(self, output_path: str = "compliance_summary.json"):
        """Generate an executive summary in JSON with key metrics."""
        if not self.data:
            return {}
            
        status_counts = {}
        for entry in self.data:
            status = entry['status']
            status_counts[status] = status_counts.get(status, 0) + 1
            
        summary = {
            "report_generated": datetime.now().isoformat(),
            "total_evaluations": len(self.data),
            "time_span": {
                "start": self.data[0]['simulation_time'],
                "end": self.data[-1]['simulation_time']
            },
            "status_distribution": status_counts,
            "compliance_rate": status_counts.get('FULLY_ADMISSIBLE', 0) / len(self.data),
            "critical_violations": [
                {
                    "time": entry['simulation_time'],
                    "reason": entry['reason'],
                    "violations": entry['violations']
                }
                for entry in self.data if entry['status'] == 'INADMISSIBLE'
            ],
            "evidence_gates_triggered": [
                {
                    "time": entry['simulation_time'],
                    "reason": entry['reason']
                }
                for entry in self.data if 'GATE' in entry['reason']
            ]
        }
        
        with open(output_path, 'w') as f:
            json.dump(summary, f, indent=2, default=str)
        print(f"[Report] Summary saved to: {output_path}")
        return summary


# ==========================================
# USAGE EXAMPLE WITH THE LOG FROM THE MAIN MODULE
# ==========================================
if __name__ == "__main__":
    # Instantiate plotter with the log generated by certified_dynamics.py
    plotter = DynamicsPlotter("audit_log.json")
    
    # Example 1: Noise vs. dynamic regulatory limit chart
    # The limit was: 80 * (1 - 0.0125*t), i.e. reduced by 1 dB per year
    plotter.plot_state_trajectory(
        state_idx=0,
        state_label="Noise Level (dB)",
        constraint_name="CS-23 Noise Limit",
        threshold_fn=lambda t: 80 * (1 - 0.0125 * t),  # Limit function over time
        title="Urban Air Mobility: Noise Compliance Trajectory",
        output_path="noise_compliance_plot.png"
    )
    
    # Example 2: Generate executive summary in JSON
    summary = plotter.generate_summary_report("compliance_summary.json")
    print(f"\nCompliance rate: {summary['compliance_rate']*100:.1f}%")
    print(f"Critical violations: {len(summary['critical_violations'])}")
